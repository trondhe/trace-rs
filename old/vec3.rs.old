use num::integer::Roots;
use num::traits::Num;
pub trait Scalar: Copy + Num + Default + Roots {}
impl Scalar for f32 {}
impl Scalar for f64 {}
impl Scalar for i32 {}
impl Scalar for i64 {}
pub struct Vec3<T>
where
    T: Scalar,
{
    pub x: T,
    pub y: T,
    pub z: T,
}

impl<T> Vec3<T>
where
    T: Scalar,
{
    pub fn new() -> Self {
        Vec3 {
            x: Default::default(),
            y: Default::default(),
            z: Default::default(),
        }
    }

    pub fn with_values(x: T, y: T, z: T) -> Self {
        Vec3 { x, y, z }
    }

    pub fn length(&self) -> T {
        let squared_sum = self.x * self.x + self.y * self.y + self.z * self.z;
        let length = squared_sum.sqrt();
    }

    // pub fn normalize(&mut self) {
    //     self / self.length();
    // }
}

impl<T> IntoIterator for Vec3<T>
where
    T: Scalar,
{
    type Item = T;
    type IntoIter = Vec3IntoIterator<T>;

    fn into_iter(self) -> Self::IntoIter {
        Vec3IntoIterator {
            vec3: self,
            index: 0,
        }
    }
}

pub struct Vec3IntoIterator<T>
where
    T: Scalar,
{
    vec3: Vec3<T>,
    index: usize,
}

impl<T> Iterator for Vec3IntoIterator<T>
where
    T: Scalar,
{
    type Item = T;

    fn next(&mut self) -> Option<T> {
        let result = match self.index {
            0 => self.vec3.x,
            1 => self.vec3.y,
            2 => self.vec3.z,
            _ => return None,
        };
        self.index += 1;
        Some(result)
    }
}

impl<'a, T> IntoIterator for &'a Vec3<T>
where
    T: Scalar,
{
    type Item = T;
    type IntoIter = Vec3Iterator<'a, T>;

    fn into_iter(self) -> Self::IntoIter {
        Vec3Iterator {
            pixel: self,
            index: 0,
        }
    }
}

pub struct Vec3Iterator<'a, T>
where
    T: Scalar,
{
    pixel: &'a Vec3<T>,
    index: usize,
}

impl<'a, T> Iterator for Vec3Iterator<'a, T>
where
    T: Scalar,
{
    type Item = T;
    fn next(&mut self) -> Option<T> {
        let result = match self.index {
            0 => self.pixel.x,
            1 => self.pixel.y,
            2 => self.pixel.z,
            _ => return None,
        };
        self.index += 1;
        Some(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new_is_0() {
        let vector: Vec3<f32> = Vec3::new();
        assert_eq!(vector.x, 0.);
        assert_eq!(vector.y, 0.);
        assert_eq!(vector.z, 0.);
    }

    #[test]
    fn length_of_vector() {
        assert_eq!(0, Vec3::with_values(0., 0., 0.).length());
    }
}
